GDI+

图形设备接口（，缩写 GDI）是微软视窗系统提供的应用程序接口，也是其用来表征图形对象、将图形对象传送给诸如显示器、打印机之类输出设备的核心组件。GDI 是视窗操作系统（Microsoft Windows）的三大核心部件（也称“子系统”）之一。GDI+ 在 GDI 的基础上调整了编程模型，同时加入了渐变色画刷、Alpha混合等功能。

GDI用来完成一些和绘制有关的工作，像直线或曲线的绘制，文字渲染，调色板控制。它不能用来直接绘制一些界面元素，像窗口、菜单等等，这些工作由用户子系统来完成，位于user32.dll中，它是建立在GDI之上的一个软件层。其他系统也有类似GDI的东西，比如Macintosh的Quartz（传统的QuickDraw），和GTK的GDK/Xlib。

GDI最大的好处是它有可以直接访问硬件设备的能力。通过GDI可以非常容易的在不同类型的设备上绘制图形，像显示屏和打印机或类似的显示设备。这些能力是微软Windows系统“所见即所得”程序的核心。

简单的不需要快速图形渲染的游戏可能会用到GDI。但是GDI对一些高级的动画制作无能为力，它缺少显卡中帧的概念，还缺少3D图形硬件光栅化的支持等等。现代的游戏通常使用DirectX和OpenGL而不是GDI，因为这些技术能更好的让程序员利用硬件的特性来加速图形图像的显示。

在DOS时期，应用程式如果要对于显示装置做输出的话，必须使用INT 10，或对于VGA卡直接I/O，或直接对VRAM所在的记忆体位置作填值。但VGA卡当时日新月异，各家的VGA卡在其I/O ports的定义并不一致，虽中间有推出一个名为VESA SVGA的显示卡驱动程式的共用标准，但由于DOS时先天的64KB的分页限制，仍有许多不便。

微软在开发Windows时，发现这个问题，于是决定打造一个GDI子系统，将显示装置改以API的方式进行操作，以便将各VGA卡的差异透过各VGA卡厂商自行制作的驱动程式来衔接GDI，来打消各VGA卡在操作上的彼此差异。

但微软很快就被其他的程式开发者告知，GDI太慢了，因此Microsoft就再出一个WING用于Windows 3.0/3.1，让应用程式能够直接对VRAM进行填值，以加速绘图的相关计算。

后来，WING再改为DirectDraw成为DirectX的一部份，直到DirectX 7。（DirectX 8以后，DirectX中2D与3D显示技术合并，开始进入全3D的贴图计算方式）

微软在推.Net Framework时，又再把GDI用.Net Framework方式进行封装，可是由于GDI本身的限制，再加上微软自己在MSDN Library上面的文件在实用性上欠缺实证（有些功能已有技术文件，但从未做出实际可用的功能），再加上GDI+在图形计算与显示不算快，以及先后饱受远端程式码执行的漏洞等问题之下，使得其无法成为微软在图形子系统的主流。

直到DirectX 10时，已经进入以DirectX的COM为基础，以.Net Framework方式进行封装的XNA之时代。XNA身兼DirectX的效能与.Net Framework的使用便利性，目前被应用于XBOX系列的游戏主机上，现已成为新一代的图形子系统的主流。

GDI+从Windows XP作业系统开始引入，提供二维的向量图形，改进旧有的GDI，加强的视觉化属性，例如边界，渐变和透明。通过GDI+，能够直接将BMP转成JPG或其它格式的图片，还能够生成SVG、Flash等。GDI+ 使用ARGB的值来表示颜色。GDI+的双缓冲技术可以提高绘图效率，可避免荧幕闪烁。

GDI+号称提供了硬件加速功能，可以直接访问硬件。但这似乎是夸饰的说法，GDI+无法直接使用VGA卡上的GPU来加速绘图的相关计算，因此在绘图效能上远远不及DirectX，只能做到Lock记忆体进行操作。（GDI+只是一组重新封装GDI的API，DirectX则是从COM到底层的显示卡驱动程式的组合）

随GDI+推出了加强型EMF，即EMF+，可以同时支持GDI和GDI+。Microsoft .NET透过System.Drawing命名空间提供对GDI+的支援。The GDI+ 的DLL可移植到旧有的Windows版本上。

GDI+ 类似Apple的Quartz 2D子系统，以及属于开放源码（open-source）的libart和Cairo库。

