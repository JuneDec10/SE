抽象工厂

抽象工厂模式（）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。

举个例子来说，比如一个抽象工厂类叫做codice_1（文档创建器），此类提供创建若干种产品的接口，包括codice_2（创建信件）和codice_3（创建简历）。其中，codice_2返回一个codice_5（信件），codice_3返回一个codice_7（简历）。系统中还有一些codice_1的具体实现类，包括codice_9和codice_10。这两个类对codice_1的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用codice_9的实例可以创建codice_13和codice_14，用codice_10的实例可以创建codice_16和codice_17）。这些具体的“信件”和“简历”类均继承自抽象类，即codice_5和codice_7类。客户端需要创建“信件”或“简历”时，先要得到一个合适的codice_1实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂codice_1中得到了codice_5或codice_7类的引用，而不是具体类的对象引用。

“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。

使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。

抽象工厂模式的实质是“提供接口，创建一系列相关或独立的对象，而不指定这些对象的具体类。”

具体的工厂决定了创建对象的具体类型，而且工厂就是对象实际创建的地方（比如在C++中，用“new”操作符创建对象）。然而，抽象工厂只返回一个指向创建的对象的抽象引用（或指针）。

这样，客户端程序调用抽象工厂引用的方法，由具体工厂完成对象创建，然后客户端程序得到的是抽象产品的引用。如此使客户端代码与对象的创建分离开来。

因为工厂仅仅返回一个抽象产品的引用（或指针），所以客户端程序不知道（也不会牵绊于）工厂创建对象的具体类型。然而，工厂知道具体对象的类型；例如，工厂可能从配置文件中读取某种类型。这时，客户端没有必要指定具体类型，因为已经在配置文件中指定了。通常，这意味着：


codice_24接口中的codice_25方法返回codice_26类型的对象。返回codice_26的哪种实现依赖于使用codice_24的哪种实现。

需要注意的是，为了简洁起见，以上类图仅仅展示了创建一个类型对象的工厂。而在抽象工厂模式中，通常一个工厂能够创建若干种不同类型的对象。

假设我们有两种产品接口 Button 和 Border ，每一种产品都支持多种系列，比如 Mac 系列和 Windows 系列。这样每个系列的产品分别是 MacButton, WinButton, MacBorder, WinBorder 。为了可以在运行时刻创建一个系列的产品族，我们可以为每个系列的产品族建立一个工厂 MacFactory 和 WinFactory 。每个工厂都有两个方法 CreateButton 和 CreateBorder 并返回对应的产品，可以将这两个方法抽象成一个接口 AbstractFactory 。这样在运行时刻我们可以选择创建需要的产品系列。

我们的产品结构是这样的
对应的工厂是这样的
那么客户可以根据需要选择 Mac 风格或者 Win 风格来创建 Button 或 Border

那么客户可以根据需要选择 Mac 风格或者 Win 风格的 Button 或 Border 来创建

public class WinFactory {
在以下情况可以考虑使用抽象工厂模式：



