线程

线程（）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（），但轻量进程更多指内核线程（），而把用户线程（）称为线程。

线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如平台的；或者由内核与用户进程，如Windows 7的线程，进行混合调度。

同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（），自己的寄存器环境（），自己的线程本地存储（）。

一个进程可以有很多线程，每条线程并行执行不同的任务。

在多核或多，或支持的上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单单核的计算机上，使用多线程技术，也可以把进程中负责处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的线程执行密集计算，从而提高了程序的执行效率。

执行绪有四种基本状态，分别为：

操作系统使用的线程叫做线程，支持内核线程、轻权进程和用户线程。一个进程可有大量用户线程；大量用户线程复用少量的轻权进程，轻权进程与内核线程一一对应。用户级线程在调用核心服务时（如文件读写），需要“捆绑（）”在一个上。永久捆绑（一个固定被一个用户级线程占用，该移到池之外）和临时捆绑（从池中临时分配一个未被占用的）。在调用系统服务时，如果所有已被其他用户级线程所占用（捆绑），则该线程阻塞直到有可用的。如果执行系统线程时阻塞（如codice_1调用），则当前捆绑在上的用户级线程也阻塞。

线程的头文件是codice_2。

其中包括：（永久捆绑）, THR_NEW_LWP（创建新放入池），若两者同时指定则创建两个新，一个永久捆绑而另一个放入池。

线程（），简称，是线程的标准。该标准定义了创建和操纵线程的一整套。在类操作系统（、、等）中，都使用作为操作系统的线程。操作系统也有其移植版pthreads-win32。

线程的头文件是codice_3。

线程是的一部分，上下文包括：寄存器、核心栈、线程环境块和用户栈。

线程的头文件是codice_4，仅适用于操作系统。

2011年8月12日，国际标准化组织（）发布了第三个C++标准，即ISO/IEC 14882:2011，简称ISO C++ 11标准。该标准第一次把线程的概念引入C++标准库。平台运行的和平台运行的g++4.7，都完美支持C++11线程。

C++ 11线程的头文件是codice_5。

2011年12月8日，国际标准化组织（）发布了第三个C语言标准，即ISO 9899:2011，简称标准。该标准第一次把线程的概念引入C语言标准库。

C11线程仅仅是个“建议标准”，也就是说100%遵守C11标准的C编译器是可以不支持C11线程的。根据C11标准的规定，只要编译器预定义了 __STDC_NO_THREADS__(C11)，就可以没有codice_6头文件，自然也就也没有下列函数。

C11线程的头文件是codice_6。


