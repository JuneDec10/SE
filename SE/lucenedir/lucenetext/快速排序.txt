快速排序

快速排序（），又称划分交换排序（），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序formula_1个项目要formula_2（大O符号）次比较。在最坏状况下则需要formula_3次比较，但这种状况并不常见。事实上，快速排序formula_4通常明显比其他演算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。

快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

步骤为：

递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个演算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
在简单的伪代码中，此算法可以被表示为：

上面简单版本的缺点是，它需要formula_5的额外储存空间，也就跟归并排序一样不好。额外需要的记忆体空间配置，在实际上的实作，也会极度影响速度和快取的效能。有一个比较复杂使用原地（in-place）分割算法的版本，且在好的基准选择上，平均可以达到formula_6空间的使用复杂度。

这是原地分割演算法，它分割了标示为"左边（left）"和"右边（right）"的序列部份，借由移动小于codice_1的所有元素到子序列的开头，留下所有大于或等于的元素接在他们后面。在这个过程它也为基准元素找寻最后摆放的位置，也就是它回传的值。它暂时地把基准元素移到子序列的结尾，而不会被前述方式影响到。由于演算法只使用交换，因此最后的数列与原先的数列拥有一样的元素。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。

一旦我们有了这个分割演算法，要写快速排列本身就很容易：

这个版本经常会被使用在命令式语言中，像是C语言。

快速排序是二叉查找树（二元搜寻树）的一个空间最佳化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个演算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分割版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。

快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的执行时间总是formula_7。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况效能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要formula_8的空间。然而，堆排序需要有效率的随机存取才能变成可行。

快速排序也与归并排序（Mergesort）竞争，这是另外一种递回排序算法，但有坏情况formula_7执行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和储存在慢速存取媒体上像是磁碟储存或网路连接储存的非常巨大数列。尽管快速排序可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要formula_5额外的空间。

从一开始快速排序平均需要花费formula_7时间的描述并不明显。但是不难观察到的是分割运算，阵列的元素都会在每次回圈中走访过一次，使用formula_12的时间。在使用结合（concatenation）的版本中，这项运算也是formula_12。

在最好的情况，每次我们执行一次分割，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递回调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作formula_14次巢状的调用。这个意思就是调用树的深度是formula_6。但是在同一阶层的两个程序调用中，不会处理到原来数列的相同部份；因此，程序调用的每一阶层总共全部仅需要formula_12的时间（每个调用有某些共同的额外耗费，但是因为在每一阶层仅仅只有formula_12个调用，这些被归纳在formula_12系数中）。结果是这个演算法仅需使用formula_7时间。

另外一个方法是为formula_20设立一个递回关系式，也就是需要排序大小为formula_1的数列所需要的时间。在最好的情况下，因为一个单独的快速排序调用牵涉了formula_12的工作，加上对formula_23大小之数列的两个递回调用，这个关系式可以是：

formula_24

解决这种关系式型态的标准数学归纳法技巧告诉我们formula_25。

事实上，并不需要把数列如此精确地分割；即使如果每个基准值将元素分开为99%在一边和1%在另一边，调用的深度仍然限制在formula_26，所以全部执行时间依然是formula_7。

然而，在最坏的情况是，两子数列拥有大各为formula_28 和formula_29，且调用树（call tree）变成为一个formula_1个巢状（nested）呼叫的线性连串（chain）。第formula_31 次呼叫作了formula_32的工作量，且formula_33递回关系式为：

formula_34

这与插入排序和选择排序有相同的关系式，以及它被解为formula_35。

乱数快速排序有一个值得注意的特性，在任意输入资料的状况下，它只需要formula_7的期望时间。是什么让随机的基准变成一个好的选择？

假设我们排序一个数列，然后把它分为四个部份。在中央的两个部份将会包含最好的基准值；他们的每一个至少都会比25%的元素大，且至少比25%的元素小。如果我们可以一致地从这两个中央的部份选出一个元素，在到达大小为1的数列前，我们可能最多仅需要把数列分割formula_37次，产生一个formula_7演算法。

不幸地，乱数选择只有一半的时间会从中间的部份选择。出人意外的事实是这样就已经足够好了。想像你正在翻转一枚硬币，一直翻转一直到有formula_39次人头那面出现。尽管这需要很长的时间，平均来说只需要formula_40次翻动。且在formula_39次翻动中得不到formula_39次人头那面的机会，是像天文数字一样的非常小。借由同样的论证，快速排序的递回平均只要formula_43的呼叫深度就会终止。但是如果它的平均呼叫深度是formula_6且每一阶的呼叫树状过程最多有formula_1个元素，则全部完成的工作量平均上是乘积，也就是formula_7。

即使如果我们无法随机地选择基准数值，对于它的输入之所有可能排列，快速排序仍然只需要formula_7时间。因为这个平均是简单地将输入之所有可能排列的时间加总起来，除以formula_1这个因数，相当于从输入之中选择一个随机的排列。当我们这样作，基准值本质上就是随机的，导致这个演算法与乱数快速排序有一样的执行时间。

更精确地说，对于输入顺序之所有排列情形的平均比较次数，可以借由解出这个递回关系式可以精确地算出来。

formula_49。

在这里，formula_29是分割所使用的比较次数。因为基准值是相当均匀地落在排列好的数列次序之任何地方，总和就是所有可能分割的平均。

这个意思是，平均上快速排序比理想的比较次数，也就是最好情况下，只大约比较糟39%。这意味著，它比最坏情况较接近最好情况。这个快速的平均执行时间，是快速排序比其他排序演算法有实际的优势之另一个原因。

被快速排序所使用的空间，依照使用的版本而定。使用原地（in-place）分割的快速排序版本，在任何递回呼叫前，仅会使用固定的-{额外空间}-。然而，如果需要产生formula_6巢状递回呼叫，它需要在他们每一个储存一个固定数量的资讯。因为最好的情况最多需要formula_6次的巢状递回呼叫，所以它需要formula_6的空间。最坏情况下需要formula_12次巢状递回呼叫，因此需要formula_12的空间。

然而我们在这里省略一些小的细节。如果我们考虑排序任意很长的数列，我们必须要记住我们的变数像是"left"和"right"，不再被认为是占据固定的空间；也需要formula_6对原来一个formula_1项的数列作索引。因为我们在每一个堆叠框架中都有像这些的变数，实际上快速排序在最好跟平均的情况下，需要formula_58空间的位元数，以及最坏情况下formula_7的空间。然而，这并不会太可怕，因为如果一个数列大部份都是不同的元素，那么数列本身也会占据formula_7的空间位元组。

非原地版本的快速排序，在它的任何递回呼叫前需要使用formula_12空间。在最好的情况下，它的空间仍然限制在formula_12，因为递回的每一阶中，使用与上一次所使用最多空间的一半，且

它的最坏情况是很恐怖的，需要

空间，远比数列本身还多。如果这些数列元素本身自己不是固定的大小，这个问题会变得更大；举例来说，如果数列元素的大部份都是不同的，每一个将会需要大约formula_6为原来储存，导致最好情况是formula_7和最坏情况是formula_67的空间需求。

选择算法（selection algorithm）可以选取一个数列的第formula_39个最小值；一般而言这是比排序还简单的问题。一个简单但是有效率的选择算法与快速排序的作法相当类似，除了对两个子数列都作递回呼叫外，它仅仅针对包含想要的元素之子数列作单一的结尾递回（tail recursive）呼叫。这个小改变降低了平均复杂度到线性或是formula_69时间，且让它成为一个原地算法。这个算法的一种变化版本，可以让最坏情况下降为formula_12（参考选择算法来得到更多资讯）。

相反地，一旦我们知道一个最坏情况的formula_12选择算法是可以利用的，我们在快速排序的每一步可以用它来找到理想的基准（中位数），得到一种最坏情况下formula_7执行时间的变化版本。然而在实际的实作中，这种版本一般而言相当慢。

迭代法
递归法
函数法
迭代法
递归法

def quick_sort(lst):
 DEFINE sort == [small][]

从尾端取元素作为比较基准
从正中间取元素作为比较基准
This example demonstrates the use of an arbitrary predicate in a functional language.

或者


1. David M. W. Powers. Parallelized Quicksort with Optimal Speedup. "Proceedings of International Conference on Parallel Computing Technologies". [[Novosibirsk]]. 1991.

[[Category:排序算法]]
[[Category:1961年科学]]

[[no:Sorteringsalgoritme#Quick sort]]