版本控制

版本控制（）是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软体工程技巧，借此能在软体开发的过程中，确保由不同人所编辑的同一程式档案都得到同步。

透过文档控制（），能记录任何工程专案内各个模组的改动历程，并为每次改动编上序号。

一种简单的版本控制形式如下：赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推。最简单的例子是，最初的版本指定为“1”，当做了改变之后，版本编号增加为“2”，以此类推。

借此，版本控制能提供专案的设计者，将设计回复到之前任一状态的选择权，这种选择权在设计过程进入死胡同时特别重要。

理论上所有的资讯记录都可以加上版本控制，在过去的实务中，除了软体开发的流程，其它的领域中很少有使用较复杂的版本控制技巧与工具（虽然可能为其带来许多好处）。目前已有人开始用版本控制软体来管理CAD电子档案，电路板设计，来补足本来由人手工执行的传统版本控制。

软体设计师常会利用版本控制来追踪、维护源码、文件以及设定档等等的改动，并且提供控制这些改动控制权的程序。

在最简单的情况下，软体设计师可以自己保留一个程式的许多不同版本，并且为它们做适当的编号。这种简单的方法已被用在很多大型的软体专案中。该方法虽然可行，但不够有效率。除了必须同时维护很多几乎一样的源码备份外；而且极度依赖软体设计师的自我修养与开发纪律，但这却常是导致错误发生的原因。

有时候，一个程式同时存有两个以上的版本也有其必要性，例如：在一个为了部署的版本中程式错误已经被修正、但没有加入新功能；在另一个开发版本则有新的功能正在开发、也有新的错误待解决，这使得同时间需要不同的版本并修改。

此外，为了找出只存在于某一特定版本中（为了修正了某些问题、或新加功能所导致）的程式错误、或找出程式错误出现的版本，软体除错者也必须借由比对不同版本的程式码以找出问题的位置。

最简单的版本控制就是保留软体不同版本的数份，并且适当编号。许多大型开发案都是使用这种简单技巧。虽然这种方法能用，但是很没效率。一是因为保存的数份几乎完全一样，也因为这种方法要高度依靠开发者的自我纪律，而常导致错误。因此，有人开发出了将部份或全部版本控制工作自动化的版本控制系统。

大部份的版本控制软体采用差分编码：只保留档案相继版本之间的差异，这个方法可以更有效的储存数个版本的档案。

大部分的软体开发案，会有好几个开发人员同时工作。如果两个人员同时要改变同一个档案，而没有管理存取权限，很可能会覆写彼此的工作。

所以权限管理控制系统会在两种方法中择一解决：采用中央式系统，由中央权威管理存取权限；或是像分散式系统容许多个单位同时进行，包括同时更动同一档案。

传统上版本控制系统都是采用中央式系统：所有版本控制的工作在一个伺服器进行，由中央权威管理存取权限「锁上」档案库中的档案，一次只让一个开发者工作。

2000年后，、、和GNU开始用分散式系统：开发者直接在各自的本地档案库工作，并容许多个开发者同时更动同一档案，而各个档案库有另一个合并各个改变的功能。这个方式让开发者能不靠网路也能继续工作，也让开发者有充分的版本控制能力，而不需经中央权威许可。分散式系统仍然可以有档案上锁功能。

分散式系统Linux内核的发明人林纳斯·托瓦兹就是分散式版本控制系统的支持者，他开发了目前被开源社群广泛使用的分散式版本控制系统Git。

档案上锁功能能对高难度的合并（例如大幅更改大档案或档案群的许多部份）提供一些保护，但其他开发者仍然可以绕过版本控制系统改变档案（这本身就是很大的问题）。所以档案上锁功能带来的功效与副作用一直饱受争议。

有些进步的版本控制工具提供更多功能，例如：

维基百科用的MediaWiki也有版本控制的功能。



注：多数不提供中文语言界面-{}-包（一部分本身即基于命令行接口），一部分对中文没有有很好的支持，处理中文时有乱码。但一般选用支持UNICODE的软件时，CJK便不成问题。


