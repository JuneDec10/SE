回答集编程

回答集编程是语法上类似传统逻辑编程而语义上密切于非单调逻辑的一种声明式编程。在传统逻辑编程和回答集编程之间的主要区别是如何表示否定为失败。在传统逻辑编程中，否定为失败指示推导失败；在回答集编程中，它指示一个文字的一致性。

回答集编程由规则的集合构成，每个规则由一个"头部"和一个"后部"构成:

formula_1

规则的头部和后部二者都是文字的集合，每个文字都是可能被否定的原子。与传统逻辑程序相反，原子都是命题而不是一阶的，并且可以使用两种形式的否定去否定它们: 经典否定(指示为 formula_2)和否定为失败(指示为 formula_3)。文字要么是原子要么是(使用经典否定)否定的原子。下面是一个例子程序:

formula_4<br>
formula_5<br>
formula_6

依据第一个规则，formula_7 是真，只要 formula_8 是真，并且 formula_9 可以被假定为假而不产生矛盾。

程序的语义基于它的回答集，每个回答集都是文字集合。对于不包含否定为失败的程序，程序的语义基于闭包和最小性的概念:


如果程序包含使用否定为失败否定的一些文字，语义要求额外的简约概念:


文字集合是一个程序的回答集，如果它是这个程序在这个集合自身下的简约的回答集。换句话说，可以通过运行下列非确定性的算法来计算一个回答集可以:

最初的文字集合 L 的选择是非确定性的。确定 L 是否为一个回答集的算法，首先计算程序在 L 下的简约，并接着检查 L 是否是这个无否定为失败的程序的回答集。

一个回答集程序可以有零个、一个或多个回答集。一个程序蕴涵一个文字，如果它的所有的回答集都包含这个文字。

与 Prolog 相反，回答集程序的语义不依赖于规则的求值和原子在每个规则中的特定次序。

检查一个程序的回答集的存在性的复杂性，和检查一个程序是否蕴涵一个文字复杂性，范围是从 P 到多项式层次的第二级，依赖于一个程序可以满足也可以不满足的一组条件(就是说分层、头部中的析取)。

实现了回答集编程的三个系统是：smodels、dlv 和 cmodels。


