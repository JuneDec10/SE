布尔代数

在抽象代数中，布尔代数（）是捕获了集合运算和逻辑运算二者的根本性质的一个代数结构（就是说一组元素和服从定义的公理的在这些元素上运算）。特别是，它处理集合运算交集、并集、补集；和逻辑运算与、或、非。
例如，逻辑断言陈述"a"和它的否定¬"a"不能都同时为真，
相似于集合论断言子集"A"和它的补集"A"有空交集，

因为真值可以在逻辑电路中表示为二进制数或电平，这种相似性同样扩展到它们，所以布尔代数在电子工程和计算机科学中同在数理逻辑中一样有很多实践应用。在电子工程领域专门化了的布尔代数也叫做逻辑代数，在计算机科学领域专门化了布尔代数也叫做布尔逻辑。

布尔代数也叫做布尔格。关联于格（特殊的偏序集合）是在集合包含"A" ⊆ "B"和次序 "a" ≤ "b"之间的相似所预示的。考虑{"x","y","z"}的所有子集按照包含排序的格。这个布尔格是偏序集合，在其中{"x"}  ≤ {"x","y"}。任何两个格的元素，比如"p" = {"x","y"}和"q" = {"y","z"}，都有一个最小上界，这里是{"x","y","z"}，和一个最大下界，这里是{"y"}。这预示了最小上界（并或上确界）被表示为同逻辑OR一样的符号"p"∨"q"；而最大下界（交或下确界）被表示为同逻辑AND一样的符号"p"∧"q"。

这种格释义有助于一般化为海廷代数，它是免除要么一个陈述要么它的否定必须为真的限制的布尔代数。海廷代数对应于直觉逻辑，而布尔代数对应于经典逻辑。

布尔代数又译为-{zh-hans:布林代数; zh-hant:布林代数;}-，然而布尔代数得名于乔治·布尔，他是爱尔兰科克的皇后学院的英国数学家。布林（boolean）在英文中的意思是「布林的」，这是为了表彰布林的贡献，而「布林」只是一种音译。

术语“布尔代数”得名于乔治·布尔（1815–1864），他是自学成材的英国数学家。他最初在1847年出版的一个小册子《逻辑的数学分析》中介入了代数逻辑系统，用来响应在奥古斯都·德·摩根和William Hamilton之间的公开论战，后来又出现在1854年出版的更充实的书《思维规律》中。布尔的公式化在一些重要方面不同于上述描述。例如，布尔的合取和析取不是一对对偶的运算。布尔代数出现在1860年代威廉姆·斯坦利·杰文斯和查尔斯·皮尔士的论文中。到了1890年Ernst Schröder写的《Vorlesungen》，我们才有了布尔代数和分配格的首次系统表述。首次用英语写的对布尔代数的广泛处置是阿弗烈·诺夫·怀海德在1898年的《泛代数》。在现代公理化意义上的作为公理化代数结构的布尔代数开始于Edward Vermilye Huntington 1904年的论文。布尔代数随着Marshall Stone在1930年代的工作和Garrett Birkhoff在1940年的《格理论》而进入了严肃数学时期。在1960年代，Paul Cohen、Dana Scott和其他人使用布尔代数的分支也就是力迫和布尔值模型，深入发现了数理逻辑和公理化集合论中的新成果。

布尔代数是一个集合A，其上定义了以下结构：
这些运算满足以下条件：∀a，b，c∈A，

上面的前三对公理：结合律、交换律和吸收律，意味着 (A,∧,∨)是一个格。所以布尔代数也可以定义为一个有补分配格。

从这些公理，你可以展示出最小元素0、最大元素1和任何元素a的补a'都是唯一确定的。

另外，∀a,b∈A，下列恒等式也成立：

在上述基本定义基础上，布尔代数中常见的还有以下的运算：

注意：-和→，+和↔是对偶的。即a→b = (a-b)'，a↔b=(a+b)'。

布尔代数的各种运算同时也被应用于集合论和逻辑学，在不同的上下文有不同的名称。具体的符号和名称如下：



在"k"元素集合"X"上有"k"个"n"元运算"f": "X"→"X"，因此在{0,1}上有2个"n"元运算。所以得出所有布尔代数，不论大小都两个常量或“零元”运算，四个一元运算，16个二元运算，256个三元运算，以此类推，它们叫做给定布尔代数的布尔运算。只有一个例外就是一个元素的布尔代数，它叫做退化的或平凡的（被一些早期作者禁用），布尔代数的所有运算可以被证明是独特的。（在退化情况下，给定元数的所有运算都是同样的运算因为对所有输入都返回同样结果。）

在{0,1}上的运算可以用真值表展出，选取0和1为真值假和真。它们可以按统一和不依赖应用的方式列出，允许我们命名或至少单独列出它们。这些名字对布尔运算提供方便的简写。"n"元运算的名字是2位的二进制数。有2个这种运算，你不能得到更简明的命名法了!

下面展示元数从0到2的所有运算的这种格局和关联的名字。

这些表格继续到更高元数上，对"n"元有2行，每个行给出"n"个变量"x",…"x"的一个求值或绑定，而每列都有表头"f"，它们给出第"i"个"n"元运算"f"("x",…,"x")在这个求值下的值。运算包括变量本身，例如"f"是"x"而"f"是"x" (作为它的一元对应者的两个复件)而"f"是"x" (没有一元对应者)。否定或补¬"x"出现为"f"再次出现为"f"，连同"f" (¬"x"在1元时没有出现)，析取或并"x"∨"x"出现为"f"，合取或交"x"∧"x"出现为"f"，蕴涵"x"→"x"出现为"f"，异或或对称差"x"⊕"x"出现为"f"，差集"x"−"x"出现为"f"等等。对布尔函数的其他命名或表示可参见零阶逻辑。

作为关于它的形式而非内容的次要详情，一个代数的运算传统上组织为一个列表。我们这里通过在{0,1}上有限运算索引了布尔代数的运算，上述真值表表示的排序首先按元数，其次为每个元数运算的列出表格。给定元数的列表次序是如下两个规则确定的。

同任何格一样，布尔代数 ("A", formula_3, formula_4)可以引出偏序集（"A", ≤），通过定义

事实上你还可以把布尔代数定义为有最小元素0和最大元素1的分配格 ("A", ≤) (考虑为偏序集合)，在其中所有的元素"x"都有补¬"x"满足

这里的formula_3和formula_4用来指示两个元素的下确界（交）和上确界（并）。还有，如果上述意义上的补存在，则它们是可唯一确定的。

代数的和序理论的观点通常可以交替的使用，并且二者都是有重要用处的，可从泛代数和序理论引入结果和概念。在很多实际例子中次序关系、合取（逻辑与）、析取（逻辑或）和否定（逻辑非）都是自然的可获得的，所以可直接利用这种联系。

你还可以把来自序理论的对偶性的普遍认识应用于布尔代数。特别是，所有的布尔代数的次序对偶，或者等价的说通过对换formula_3与formula_4所获得的代数，也是布尔代数。一般的说，布尔代数的任何有效的规律都可以变换成另一个有效的对偶规律，通过对换0与1，formula_3与formula_4，和≤与≥。

在布尔代数"A"和"B"之间的同态是一个函数"f" : "A" → "B"，对于在"A"中所有的"a", "b"都有:

接着对于在"A"中所有的"a"，"f"(¬"a") = ¬"f"（"a"）同样成立。所有布尔代数的类，和与之在一起的态射的概念，形成了一个范畴。从"A"到"B"的同构是双射的从"A"到"B"的同态。同构的逆也是同构，我们称两个布尔代数"A"和"B"为“同构”的。从布尔代数理论的立场上，它们是不能区分的；它们只在它们的元素的符号上有所不同。

布尔同态是在布尔代数"A"和"B"之间的函数"h": "A"→"B"使得对于所有布尔运算"f"有

布尔代数的范畴Bool有所有布尔代数作为对象和在它们之间的布尔同态作为态射。

从两元素布尔代数2到所有布尔代数存在唯一的同态，因为所有态射必须保持两个常量而它们是2的仅有元素。有这种性质的布尔代数叫做初始布尔代数。可以证明任何两个初始布尔代数都是同构的，所以在同构的意义下2就是初始布尔代数。

在其他方向上，从布尔代数"B"到2存在很多同态。任何这种同态都把"B" 划分成映射到1的元素和映射到0的元素。由前者组成的"B"的子集叫做"B"的超滤子。在"B"是有限的时候，它的超滤子配对于它的原子；一个原子被映射到1而其他被映射到0。"B"的每个超滤子因此由"B"的一个原子和所有其上的元素组成；所以精确的有"B"的一半元素在这个超滤子中，并且有和原子一样的多的超滤子。

对于无限布尔代数，超滤子的概念变得相当微妙。大于等于原子的那些元素总是形成超滤子，但是很多其他集合也能形成；例如在整数的有限和余有限集合的布尔代数中，余有限集合形成了超滤子即使它们中没有原子。类似的整数的幂集有包含给定整数的所有子集的集合作为超滤子之一；有可数多个这种“标准”超滤子，它们可以用整数自身来识别，但是还有不可数多个“非标准”超滤子。这些形成了非标准分析的基础，它提供了对这种经典不相容对象作为无穷小和delta函数的表述。

每个布尔代数 ("A", formula_3, formula_4)都引出一个环（"A", +, *），通过定义"a" + "b" = ("a" formula_3 ¬"b") formula_4 ("b" formula_3 ¬"a") (这个运算在集合论中叫做“对称差”在逻辑中叫做XOR（异或）)和"a" * "b" = "a" formula_3 "b"。这个环的零元素符合布尔代数的0；环的乘法单位元素是布尔代数的1。这个环有对于"A"中的所有的"a"保持"a" * "a" = "a"的性质；有这种性质的环叫做布尔环。

反过来，如果给出布尔环"A"，我们可以把它转换成布尔代数，通过定义"x" formula_4 "y" = "x" + "y" + "xy"和"x" formula_3 "y" = "xy"。因为这两个运算是互逆的，我们可以说每个布尔环引发一个布尔代数，或反之。此外，映射"f" : "A" → "B"是布尔代数的同态，当且仅当它是布尔环的同态。布尔环和代数的范畴是等价的。

布尔代数"A"的理想是一个子集"I"，对于在"I"中的所有"x", "y"我们有"x" formula_4 "y"在"I"中，并且对于在"A"中的所有"a"我们有"a" formula_3 "x"在"I"中。理想的概念符合在布尔环"A"中环理想的概念。"A"的理想"I"叫做“素理想”，如果"I" ≠ "A"；并且如果"a" formula_3 "b"在"I"中总是蕴涵"a"在"I"中或"b"在"I"中。"A"的理想"I"叫做“极大理想”，如果"I" ≠ "A"并且真正包含"I"的唯一的理想是"A"自身。这些概念符合布尔环"A"中的素理想和极大理想的环理论概念。

“理想”的对偶是滤子。布尔代数"A"的“滤子”是子集"p"，对于在"p"中的所有"x", "y"我们有"x" formula_3 "y"在"p"中，并且对于在"A"中的所有"a"，如果"a" formula_4 "x" = "a"则"a"在"p"中。

可以证实所有的“有限”的布尔代数都同构于一个有限集合的所有子集的布尔代数。此外，所有的有限的布尔代数的元素-{}-数目都是二的幂。Stone的著名的布尔代数表示定理陈述了“所有的”布尔代数"A"都同构于在某个（完全不连通紧致豪斯多夫空间）拓扑空间中所有闭开集合的布尔代数。

从布尔代数的公理中去掉存在最大元1的要求产生了“广义布尔代数”。形式的说，分配格"B"是广义布尔代数，如果它有最小元0并且对于任何"B"中的元素"a"和"b"使得"a" ≤ "b"，存在一个元素"x"使得formula_32并且formula_33。定义formula_34为唯一的"x"使得formula_35并且formula_36，我们可以称结构formula_37是“广义布尔代数”，而formula_38是“广义布尔半格”。

广义布尔格完全就是布尔格的理想。

在1933年，美国数学家Edward Vermilye Huntington（1874-1952）展示了对布尔代数的如下公理化:


Herbert Robbins接着摆出下列问题: Huntington等式能否替代为它的对偶等式，并且这个新等式与结合律和交换律一起成为布尔代数的基础?通过一组叫做“Robbins代数”的公理，问题就变成了：是否所有的Robbins代数都是布尔代数?

Robbins代数的公理化:


这个问题自从1930年代一直是公开的，并成为阿尔弗雷德·塔斯基和他的学生最喜好的问题。

在1996年，William McCune在阿贡国家实验室，建造在Larry Wos、Steve Winker和Bob Veroff的工作之上，肯定的回答了这个长期存在的问题：所有的Robbins代数都是布尔代数。这项工作是使用McCune的自动推理程序EQP完成的。

布林代数的运算包含下列几种，基本包含“与”(AND)、“或”(OR)、“非”(NOT)，其中由这三种又可组合成NAND（与非）、NOR（或非）、XOR（异或）与XNOR（异或非）。

常建使用记号：“formula_41”表示AND，“＋”表示OR（如CNF和DNF中）或者XOR（如ANF中）；A中A上面的一横表示NOT；⊕表示XOR；⊙表示XNOR。




The following alternatives do not work; still searching for good template
