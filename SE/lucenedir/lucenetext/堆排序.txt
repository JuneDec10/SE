堆排序

堆排序（）是指利用-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-这种数据结构所设计的一种排序算法。-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。

若以升序排序说明，把阵列转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二元树：对于除了 root 之外的每个 node i, A[parent(i)] ≥ A[i]。

重复从最大堆积取出数值最大的 node (把 root node 和 last node 交换，把交换后的 last node 移出 heap)，并让残余的堆积维持最大堆积性质。

通常-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-是通过一维数组来实现的。在阵列起始位置为0的情形中：


在-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-的资料结构中，-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-中的最大值总是位于根节点（在优先队列中使用-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-的话-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-中的最小值位于根节点）。-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-中定义以下几种操作：


基于以上-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-相关的操作，我们可以很容易的定义堆排序。例如，假设我们已经读入一系列数据并创建了一个-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-，一个最直观的算法就是反复的调用codice_1函数，因为该函数总是能够返回-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-中最大的值，然后把它从-{zh-cn:堆;zh-tw:堆积;zh-hk:堆积;}-中删除，从而对这一系列返回值的输出就得到了该序列的降序排列。真正的原地堆排序使用了另外一个小技巧。堆排序的过程是：

堆排序的平均时间复杂度为formula_5，空间复杂度为formula_6。

