原地算法

在电脑科学中，一个原地算法（in-place algorithm）基本上不需要额外辅助的资料结构,然而,允许少量额外的辅助变数来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部份覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。

一个算法有时候会错误地被称为原地算法，只因为它用它的输出资料会覆盖掉它的输入资料。事实上这条件既不充分（在快速排序案例中所展示的）也非必要；输出资料的空间可能是固定的，或如果以输出为串流资料而言，也甚至是可能无法被数清楚的。另一方面来看，有时候要决定一个算法是不是原地，而数它的输出空间可能是比较可行的，像是底下的第一个的reverse范例；如此使得它更难去严格地定义原地算法。在理论上的应用像是log-space reduction，更是典型的总是忽略输出的空间（在这些状况，更重要的是输出为"仅能写入"）。

假设我们想要将拥有"n"个项目的阵列反过来。一个最简单作这件事的方式是这样：

不幸地，这样需要O("n")的空间来建立"b"阵列，且配置记忆体通常是一件缓慢的运算。如果我们不再需要"a"，我们可使用这个原地算法，用它自己反转的内容来覆盖掉：

在其他的例子，有数个排序算法会原地重新排放阵列内容成为排序过的顺序，包含：

快速排序通常被描述为一个原地算法，但是事实上并不是。大部份的实作需要O(log "n")的空间来支持它的分治法（divide-and-conquer）递回。

大部份选择算法也是原地，虽然在找到最后结果的过程中，有某些相当地重新排列输入阵列，但却是固定大小的结果。

在计算复杂性理论中，原地算法包含使用O(1)空间复杂度的所有算法，DSPACE(1)类型。这个类型是非常有限的，它与正规语言相等。事实上，它甚至不包含上面所列的任何范例。

因为这个原因，我们也考虑在L的算法，这类型的问题需要O(log "n")额外的空间，来成为原地。虽然这个似乎与我们先前的定义矛盾，但是我们必须认为在抽象的世界，输入的资料可以是任意巨大的。在一部真实的电脑，指标（pointer）仅需要一个小的固定数量空间，因为实体记忆体的数量是固定的，但是一般上一个大小为"n"的数列需要O(log "n")位元来作为它的索引（index）。

结果是否意指快速排序是原地的？其实一点也不—技术上来说，它需要O(log "n")空间，因为它的O(log "n")堆叠框架（stack frames）每一个都含有一个固定数量的指标（每一个大小为O(log "n")）。

辨别拥有L的原地算法拥有某些有趣的含意；举例来说，它意指存在一个（相当地复杂）原地算法，决定在一个无向图（undirected graph）中的任两个节点（nodes）之间是否存在一条路径（path），这是一个需要O("n")个额外的空间，使用典型的算法像是深度优先搜寻(depth-first search)（每个节点有个走访的位元）的问题。有些问题像是决定一个图形是否为二分图（bipartite graph）或测试两个图形使否有相同数量的连通分支，接著针对这些问题产出原地算法。参考SL有更多的资讯。

在很多情况，借由使用随机化算法（randomized algorithms），一个算法的空间需求可以被极度地裁减掉。举个范例，我们希望知道一个有"n"个顶点（vertices）的图形中的两个顶点是否位于图中同一个连接元件（connected component）。没有已知简单、决定性的（deterministic）、原地算法来决定这件事，但是如果我们简单地由一个顶点开始，且执行大约20"n"步的随机走路（random walk），那我们会偶遇到其他顶点来提供它不是在同一个元件（component）中的机会是非常地高。类似地，对于质数测试（primality test）有简单的随机化原地算法像是米勒-拉宾检验，也有简单原地随机化整数分解算法像是Pollard's rho算法。参考RL和BPL有对这个现象更多的讨论。

函数程式设计（functional programming）语言经常不鼓励或不支援会覆盖资料的原地算法，因为这是副作用的一种型态；反之，他们只允许建立新的资料。然而，好的函数语言编译器（compiler）在当一个与已存在之非常相似的物件被建立时，都经常会辨识出来，然后旧的就会被丢弃掉，而且会最把这最佳化为一个简单的"引擎盖之下"转换。

基本上，有可能小心地建构原地算法而不会更动资料（除非资料已不会再被使用），但是在实际上这却很少见到。参考纯函数资料结构（purely functional data structure）。

Maciej Liśkiewicz and Rüdiger Reischuk. The Complexity World below Logarithmic Space. "Structure in Complexity Theory Conference", pp.64-78. 1994.
Omer Reingold. Undirected ST-connectivity in Log-Space. Electronic Colloquium on Computational Complexity. No. 94.

 1. Liśkiewicz and Reischuk, pg.3, Theorem 2.
